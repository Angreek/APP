<html>
    <head>
        <meta charset="utf-8">
        <link href='CSS/main.css' rel='stylesheet' type='text/css'>
        <script src='scripts/index.js'></script>
    </head>
    <body>

    <button>
        text
    </button>

    <div class="code-window" id="code-window">

    </div>

<!--Module 5
    1. https://jsfiddle.net/AndrewKuk/ew5mu7yf/17/
    2. https://jsfiddle.net/AndrewKuk/ew5mu7yf/30/
    3. https://jsfiddle.net/AndrewKuk/ew5mu7yf/33/
    4. https://jsfiddle.net/AndrewKuk/ew5mu7yf/49/
    5. https://jsfiddle.net/AndrewKuk/u3uwbukg/66/
    6. https://jsfiddle.net/AndrewKuk/u3uwbukg/72/
    7. https://jsfiddle.net/AndrewKuk/u3uwbukg/74/
    8. https://jsfiddle.net/AndrewKuk/u3uwbukg/78/
    9. https://jsfiddle.net/AndrewKuk/x4rkcyu0/122/

    1. Создать функцию double(), которая будет принимать в качестве аргумента число и удваивать его. Удвоенное число либо пусть функция возвращает через return, либо сразу выводит через console.log. Например
double(5) выдаст 10.

2. Создать функцию bye(), которая через prompt() будет спрашивать имя пользователя и прощаться с ним, выводя на экран "До свидания, <здесь будет имя>"

3. Доработать наш пример из лекции с функцией calc(). На уроке у нас были callback-функции add(), multiply() и subtract(). Написать ещё и функции для деления, деления по модулю, возведения первого числа в степень второго.
Ну и естественно, вызвать функцию calc() с этими всеми коллбэк-функциями и двумя числами, над которыми будут производиться действия.

4. Написать функцию для подсчёта сложных процентов. Первый аргумент - это деньги на счету, второй - размер процента, третий - срок банковского вклада в годах. Функция возвращает конечную сумму на счету с учётом, что в конце года происходит начисление процентов. Если срок не завершён, то проценты прибавляются к деньгам на счёте и в следующем году уже считается процент этой суммы. То есть у нас ежегодная капитализация

5. ЗАДАЧА СО ЗВЁЗДОЧКОЙ (не обязательная для решения)
https://jsfiddle.net/jejwtx3o/ в примере по ссылке я написал на скорую руку игру крестики-нолики. Я постарался над алгоритмом проверки победы и смог сделать игру универсальной для любого размера поля. 3х3, 5х5, 100х100 - размер поля можно указать любой и код будет с ним работать одинаково.

размер можно задать константой SIZE, а размер ячеек через CELL_SIZE.

но, конкретно этот код можно улучшать и улучшать. Я предлагаю сосредоточиться на нескольких моментах.

1) есть баг, что если кликнуть на уже заполненную ячейку, то это содержимое перезапишется, то есть можно кликать на ячейки противника или много раз на свою и это будет считаться ходом. Устранить этот баг, чтобы, если по ячейке был клик, то повторный клик ни к чему бы не приводил)
2) в игре есть, как я его называю "искусственный идиот" - код, отвечающий за ходы компьютера против игрока. Он сейчас делает ходы просто случайным образом на пустые ячейки из-за чего почти всегда проигрывает. Код логики в функции checkFree().
Превратите его в подобие "искусственного интеллекта". Например, чтобы он первым своим ходом ставил нолик на центральную ячейку.
Плюс можно анализировать "вес" столбцов, строк, диагоналей. Например, если игрок ставит где-то крестик, то строка, столбец, диагональ с этим крестиком увеличивают свой вес и компьютер сортирует все поля по весу и случайно ходит туда, где вес больше, а не куда-попало.
3) мне кажется, что функции делают слишком много операций. Разбейте их на несколько, сделайте код чище
4) если удастся, то найдите более оптимальный или простой алгоритм проверки победы, который у меня в checkField()
5) наверняка там закралось ещё не мало багов, исправьте, если найдёте
6) сделайте возможность, чтобы иногда первым ходил компьютер или просто это было случайно (50% первый игрок, 50% компьютер)
    -->
    </body>
</html>